<!DOCTYPE html> <html>
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">      <title>Mediator.js</title>   <style>     body {       font-size: 16px;       line-height: 24px;       background: #fff url("bg.png");       color: #252519;       font-family: "Palatino Linotype", "Book Antiqua", Palatino, FreeSerif, serif;       padding: 0 0 50px 50px;     }     div.container {       width: 720px;       margin: 50px 0 50px 50px;     }     p {       width: 550px;     }       #documentation p {         margin-bottom: 4px;       }     a, a:visited {       padding: 0 2px;       text-decoration: none;       background: #dbe6f3;       color: #3f6fa5;     }     a:active, a:hover {       color: #dbe6f3;       background: #3f6fa5;     }     h1, h2, h3, h4, h5, h6 {       margin-top: 40px;       width: 550px;       line-height: 1.25em;     }     b.header {       font-size: 18px;     }     span.alias {       font-size: 14px;       font-style: italic;       margin-left: 20px;     }     table, tr, td {       margin: 0; padding: 0;     }       td {         padding: 2px 12px 2px 0;       }     ul {       list-style-type: circle;       padding: 0 0 0 20px;     }       li {         width: 500px;         margin-bottom: 10px;       }     code data-language="javascript", pre, tt {       font-family: Monaco, Consolas, "Lucida Console", monospace;       font-size: 12px;       line-height: 18px;       color: #555529;     }       pre {         font-size: 12px;         padding: 2px 0 2px 12px;         border-left: 6px solid #aaaa99;         margin: 0px 0 30px;       }            #ribbon {      line-height: 0;     }          #ribbon:hover {      background: none;     }          #ribbon img {      position: fixed;      top: 0;      right: 0;      border: 0;      z-index: 2;     }   </style> 
    <link rel="stylesheet" href="rainbow-espresso-libre.css">
    </head> <body>      <h1>Mediator.js</h1>        <em>A light utility class to help implement the Mediator pattern</em>         <h3>Source files:</h3>   <ol>            <li><a href="mediator.html">mediator.js</a></li>        </ol>      <h1>Mediator.js</h1>

<p>Version 0.9.0</p>

<p><strong>Breaking changes since version 0.7.0:</strong> see changelog below</p>

<p>For more information, please see </p>

<p><a href="http://thejacklawson.com/2011/06/mediators-for-modularized-asynchronous-programming-in-javascript/">Relevant blog post</a></p>

<p><a href="https://github.com/ajacksified/Mediator.js">View the project on Github</a></p>

<p><a href="http://thejacklawson.com/Mediator.js/">View the documentation</a></p>

<p>Documentation built using <a href="https://github.com/rthauby/Paige">Paige</a></p>

<h2>A light utility class to help implement the Mediator pattern for easy eventing</h2>

<p>Mediator is a simple class that allows you to register, unregister, and call
subscriber methods to help event-based, asyncronous programming.  Its purpose
is to make the usage of WebSockets, Ajax calls, DOM events, or any other
asynchronous operations easy to maintain and test.</p>

<p><em>1.12kb, minifed and gzipped</em></p>

<h2>Why?</h2>

<p>My specific use case: bind elements easily for WebSocket callbacks. But, you
may find usage in it for all kinds of things: as an event management system,
to decouple calls between javascript functions, Ajax request callbacks, and
more. There's an excellent online book that talks about Mediators more in detail
by <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#mediatorpatternjavascript">Addy Osmani</a>.</p>

<h2>Usage</h2>

<p>You can register events with the mediator two ways using channels. You can add
a predicate to perform more complex matching.  Instantiate a new mediator, and
then you can being subscribing, removing, and publishing.</p>

<p>Subscription signature:</p>

<pre><code data-language="javascript">Mediator.subscribe(channel, callback, &lt;options&gt;, &lt;context&gt;);
Mediator.once(channel, callback, &lt;options&gt;, &lt;context&gt;);
Mediator.publish(channel, &lt;data, data, ... &gt;)
Mediator.remove(channel, &lt;identifier&gt;)</code data-language="javascript"></pre>

<p>Additionally, <code data-language="javascript">on</code data-language="javascript"> and <code data-language="javascript">bind</code data-language="javascript"> are aliased to <code data-language="javascript">subscribe</code data-language="javascript">, and <code data-language="javascript">trigger</code data-language="javascript"> and
<code data-language="javascript">emit</code data-language="javascript"> are bound to <code data-language="javascript">publish</code data-language="javascript">. <code data-language="javascript">off</code data-language="javascript"> is an alias for <code data-language="javascript">remove</code data-language="javascript">.</p>

<p>Callback signature:</p>

<pre><code data-language="javascript">function(&lt;data, data ...&gt;, channel);</code data-language="javascript"></pre>

<p>Mediator.subscribe and Mediator.once options (all are optional; default is empty):</p>

<pre><code data-language="javascript">{
  predicate: function(*args){ ... }
  priority: 0|1|... 
  calls: 1|2|...
}</code data-language="javascript"></pre>

<p>Predicates return a boolean and are run using whatever args are passed in by the
publishing class. If the boolean is true, the subscriber is run.</p>

<p>Priority marks the order in which a subscriber is called.</p>

<p><code data-language="javascript">calls</code data-language="javascript"> allows you to specify how many times the subscriber is called before it
is automatically removed. This is decremented each time it is called until it
reaches 0 and is removed. If it has a predicate and the predicate does not match,
calls is not decremented.</p>

<p>A Subscriber object is returned when calling Mediator.subscribe. It allows you
to update options on a given subscriber, or to reference it by an id for easy
removal later.</p>

<pre><code data-language="javascript">{
  id, // guid
  fn, // function
  options, // options
  context, // context for fn to be called within
  channel, // provides a pointer back to its channel
  update(options){ ...} // function that accepts { fn, options, context }
}</code data-language="javascript"></pre>

<p>Examples:</p>

<pre><code data-language="javascript">var mediator = new Mediator();

// Alert data when the "message" channel is published to
// Subscribe returns a "Subscriber" object
mediator.subscribe("message", function(data){ alert(data); });
mediator.publish("message", "Hello, world");

// Alert the "message" property of the object called when the predicate function returns true (The "From" property is equal to "Jack")
var predicate = function(data){ return data.From === "Jack" };
mediator.subscribe("channel", function(data){ alert(data.Message); }, { predicate: predicate });
mediator.publish("channel", { Message: "Hey!", From: "Jack" }); //alerts
mediator.publish("channel", { Message: "Hey!", From: "Audrey" }); //doesn't alert</code data-language="javascript"></pre>

<p>You can remove events by passing in a channel, or a channel and the
function to remove or subscriber id. If you only pass in a channel,
all subscribers are removed.</p>

<pre><code data-language="javascript">// removes all methods bound directly to a channel, but not subchannels
mediator.remove("channel");

// unregisters *only* MethodFN, a named function, from "channel"
mediator.remove("channel", MethodFN);</code data-language="javascript"></pre>

<p>You can call the registered functions with the Publish method, which accepts 
an args array:</p>

<pre><code data-language="javascript">mediator.publish("channel", "argument", "another one", { etc: true });</code data-language="javascript"></pre>

<p>You can namespace your subscribing / removing / publishing as such:</p>

<pre><code data-language="javascript">mediator.subscribe("application:chat:receiveMessage", function(data){ ... });

// will call parents of the appllication:chat:receiveMessage namespace
// (that is, next it will call all subscribers of application:chat, and then
// application). It will not recursively call subchannels - only direct subscribers.
mediator.publish("application:chat:receiveMessage", "Jack Lawson", "Hey");</code data-language="javascript"></pre>

<p>You can update Subscriber priority:</p>

<pre><code data-language="javascript">var sub = mediator.subscribe("application:chat", function(data){ ... });
var sub2 = mediator.subscribe("application:chat", function(data){ ... });

// have sub2 executed first
mediator.getChannel("application:chat").setPriority(sub2.id, 0);</code data-language="javascript"></pre>

<p>You can update Subscriber callback, context, and/or options:</p>

<pre><code data-language="javascript">sub.update({ fn: ..., context: { }, options: { ... });</code data-language="javascript"></pre>

<p>You can stop the chain of execution by calling channel.stopPropagation():</p>

<pre><code data-language="javascript">// for example, let's not post the message if the from and to are the same
mediator.subscribe("application:chat", function(data, channel){
  //something with data
  channel.stopPropagation();
}, options: {
  predicate: function(data){ return data.From == data.To },
  priority: 0
});</code data-language="javascript"></pre>

<h2>Changes from Last Version</h2>

<p><strong>Version 0.9.0</strong></p>

<ul>
<li>Reversed order of recursion: now calls parents instead of children channels</li>
<li>Lowercase methods</li>
<li>Aliases: <code data-language="javascript">on</code data-language="javascript"> and <code data-language="javascript">bind</code data-language="javascript"> are aliased to <code data-language="javascript">subscribe</code data-language="javascript">, and <code data-language="javascript">trigger</code data-language="javascript"> and
<code data-language="javascript">emit</code data-language="javascript"> are bound to <code data-language="javascript">publish</code data-language="javascript">. <code data-language="javascript">off</code data-language="javascript"> is an alias for <code data-language="javascript">remove</code data-language="javascript">.</li>
<li>Moved tests to mocha from jasmine</li>
<li>Supports AMD, requirejs, and browser loading</li>
<li>Lots of cleanup around extra variables, and jslinted</li>
<li>Published to NPM under "mediator-js"</li>
<li>Added travis-ci build</li>
</ul>

<p><strong>Version 0.6.1</strong></p>

<ul>
<li>Cleaned up some typos</li>
<li>Save pointer to channel within subscription</li>
<li>Save namespace in channel</li>
<li>Fixed bugs in SetPriority</li>
</ul>

<p><strong>Version 0.6.0</strong></p>

<ul>
<li>Added ability to stop the chain of calls using c.stopPropagation()</li>
</ul>

<p><strong>Version 0.5.0</strong></p>

<ul>
<li>Added ability to access and update subscribing objects
<ul><li>Subscribers now have a unique ID and can be queried by id or by function</li>
<li>Subscriber class can have its function, context, or options updated</li>
<li>Subscriber priority can be updated post-addition</li>
<li>Channels made public by Mediator.GetChannel</li>
<li>Added a little performance test</li></ul></li>
</ul>

<p><strong>Version 0.4.2</strong></p>

<ul>
<li>Added Priority to calls, allowing you to set callback index</li>
</ul>

<p><strong>Version 0.4.1</strong></p>

<ul>
<li>Minor internal updates</li>
</ul>

<p><strong>Version 0.4.0</strong></p>

<ul>
<li>Predicate no longer acts as a channel and is moved to an options object
at the end of the subcription call.</li>
<li>Signatures changed; context moved to the end of subscriptions</li>
<li>Namespacing for subscription binding</li>
</ul>

<h2>License</h2>

<p>This class and its accompanying README and are 
<a href="http://www.opensource.org/licenses/mit-license.php">MIT licensed</a>.</p>

<h2>In Closing</h2>

<p>Have fun, and please submit suggestions and improvements! You can leave any
  issues here, or contact me at (<a href="https://twitter.com/ajacksified">@ajacksified</a>).</p> 

<script src="rainbow.min.js"></script>
<script src="generic.js"></script>
<script src="javascript.js"></script>

</body> </html>
